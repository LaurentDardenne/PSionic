<div class="wikidoc">
<p><strong>Name</strong></p>
<p style="margin-left:40px"><strong>Add-ZipEntry</strong></p>
<p><strong>SYNOPSIS</strong></p>
<p style="margin-left:40px">Ajoute une entr&eacute;e dans le catalogue d'une archive Zip existante.</p>
<p><strong>SYNTAX</strong></p>
<p style="margin-left:40px">Add-ZipEntry -InputObject &lt;Object&gt; [-ZipFile] &lt;ZipFile&gt; [[-Name] &lt;String&gt;] [-Comment &lt;String&gt;] [-EntryPathRoot &lt;String&gt;] [-Passthru] [&lt;CommonParameters&gt;]</p>
<p><strong>DESCRIPTION</strong></p>
<p style="margin-left:40px">Ajoute une entr&eacute;e dans le catalogue d'une archive .ZIP ou d'une archive auto extractible .EXE, cette entr&eacute;e peut &ecirc;tre un nom de fichier ou de r&eacute;pertoire, une cha&icirc;ne de caract&egrave;res ou un tableau
 d'octets.</p>
<p><strong>PARAMETERS</strong></p>
<p><strong>-InputObject</strong> <em>&lt;Object&gt;</em></p>
<p style="margin-left:40px; text-align:left">Contenu associ&eacute; &agrave; une entr&eacute;e d'archive.</p>
<p style="margin-left:40px; text-align:left">Les types attendus sont :</p>
<p style="margin-left:40px; text-align:left">&nbsp;- Un ou des objets fichiers ou r&eacute;pertoires,</p>
<p style="margin-left:40px; text-align:left">&nbsp;- un nom ou des noms de fichier ou de r&eacute;pertoire,</p>
<p style="margin-left:40px; text-align:left">&nbsp;- une cha&icirc;ne de caract&egrave;res</p>
<p style="margin-left:40px; text-align:left">&nbsp;ou un tableau d'octets.</p>
<p style="margin-left:40px; text-align:left">Tous les autres types d'objet seront transform&eacute;s en cha&icirc;ne de caract&egrave;res via la m&eacute;thode
<em>ToString()</em>.</p>
<table border="1" style="margin-left:40px">
<tbody>
<tr>
<td>Required?</td>
<td>True</td>
</tr>
<tr>
<td>Position?</td>
<td>named</td>
</tr>
<tr>
<td>Default value</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>Accept pipeline input?</td>
<td>true (ByValue)</td>
</tr>
<tr>
<td>Accept wildcard characters?</td>
<td>False</td>
</tr>
</tbody>
</table>
<p><strong>-ZipFile</strong> <em>&lt;ZipFile&gt;</em></p>
<p style="margin-left:40px; text-align:left">Archive cible dans laquelle on ajoute l'entr&eacute;e pr&eacute;cis&eacute;e.</p>
<p style="margin-left:40px; text-align:left">Ce param&egrave;tre attend un objet de type ZipFile et pas un nom de fichier.</p>
<table border="1" style="margin-left:40px">
<tbody>
<tr>
<td>Required?</td>
<td>True</td>
</tr>
<tr>
<td>Position?</td>
<td>0</td>
</tr>
<tr>
<td>Default value</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>Accept pipeline input?</td>
<td>false</td>
</tr>
<tr>
<td>Accept wildcard characters?</td>
<td>False</td>
</tr>
</tbody>
</table>
<p><strong>-Name</strong> <em>&lt;String&gt;</em></p>
<p style="margin-left:40px; text-align:left">Chaque entr&eacute;e d'archive est associ&eacute;e &agrave; un nom dans le catalogue. Pour les fichiers ou les r&eacute;pertoires, leurs nom sont automatiquement utilis&eacute;s comme noms d'entr&eacute;es &agrave;
 la racine de l'archive.</p>
<p style="margin-left:40px; text-align:left">Pour les cha&icirc;nes de caract&egrave;res ou les tableaux d'octets, vous devez pr&eacute;ciser un nom d'entr&eacute;e. L'usage du param&egrave;tre -EntryPathRoot n'influencera pas ce nommage.</p>
<p style="margin-left:40px; text-align:left">Lors d'un appel &agrave; la fonction Expand-ZipFile les entr&eacute;es de type string et tableau seront d&eacute;compress&eacute;es tout comme les fichiers.</p>
<table border="1" style="margin-left:40px">
<tbody>
<tr>
<td>Required?</td>
<td>False</td>
</tr>
<tr>
<td>Position?</td>
<td>1</td>
</tr>
<tr>
<td>Default value</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>Accept pipeline input?</td>
<td>true (ByPropertyName)</td>
</tr>
<tr>
<td>Accept wildcard characters?</td>
<td>False</td>
</tr>
</tbody>
</table>
<p><strong>-Comment</strong> <em>&lt;String&gt;</em></p>
<p style="margin-left:40px; text-align:left">Commentaire associ&eacute; &agrave; l'entr&eacute;e. Pour les entr&eacute;es de type string ou tableau, par d&eacute;faut leur champ contiendra le nom de leur type : [String] ou [Byte[]].</p>
<table border="1" style="margin-left:40px">
<tbody>
<tr>
<td>Required?</td>
<td>False</td>
</tr>
<tr>
<td>Position?</td>
<td>named</td>
</tr>
<tr>
<td>Default value</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>Accept pipeline input?</td>
<td>false</td>
</tr>
<tr>
<td>Accept wildcard characters?</td>
<td>False</td>
</tr>
</tbody>
</table>
<p><strong>-EntryPathRoot</strong> <em>&lt;String&gt;</em></p>
<p style="margin-left:40px; text-align:left">La nouvelle entr&eacute;e sera ajout&eacute;e dans un r&eacute;pertoire sp&eacute;cifique. Par d&eacute;faut elle est ajout&eacute;e &agrave; la racine de l'arborescence contenue dans l'archive. La valeur de ce param&egrave;tre
 doit r&eacute;f&eacute;rencer un r&eacute;pertoire existant.</p>
<p style="margin-left:40px; text-align:left">Pour &eacute;viter les collisions de nom d'entr&eacute;e lors de la compression r&eacute;cursive d'une arborescence vous devrez utiliser ce param&egrave;tre. Celui-ci permet de construire le nom de l'entr&eacute;e
 relativement au nom de r&eacute;pertoire sp&eacute;cifi&eacute;.</p>
<p style="margin-left:40px; text-align:left">Par exemple en pr&eacute;cisant 'C:\Temp\Backup', lors de la compression r&eacute;cursive de 'C:\Temp\Backup' le traitement de construction du nom d'entr&eacute;e retranchera 'C:\Temp\Backup' &agrave; chaque nom
 de fichier re&ccedil;u. Donc, pour les fichiers 'C:\Temp\Backup\File1.ps1' et 'C:\Temp\Backup\Projet\File1.ps1' les entr&eacute;es cr&eacute;&eacute;es dans le catalogue seront respectivement: File1.ps1 Projet/File.ps1.</p>
<p style="margin-left:40px; text-align:left">De pr&eacute;ciser un nom de r&eacute;pertoire diff&eacute;rent de celui d'o&ugrave; d&eacute;bute l'archivage d&eacute;clenchera une erreur et stoppera l'archivage du path en cours.</p>
<table border="1" style="margin-left:40px">
<tbody>
<tr>
<td>Required?</td>
<td>False</td>
</tr>
<tr>
<td>Position?</td>
<td>named</td>
</tr>
<tr>
<td>Default value</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>Accept pipeline input?</td>
<td>false</td>
</tr>
<tr>
<td>Accept wildcard characters?</td>
<td>False</td>
</tr>
</tbody>
</table>
<p><strong>-Passthru</strong> <em>&lt;SwitchParameter&gt;</em></p>
<p style="margin-left:40px; text-align:left">Une fois l'entr&eacute;e ajout&eacute;e au catalogue de l'archive, elle est &eacute;mise dans le pipeline.</p>
<table border="1" style="margin-left:40px">
<tbody>
<tr>
<td>Required?</td>
<td>False</td>
</tr>
<tr>
<td>Position?</td>
<td>named</td>
</tr>
<tr>
<td>Default value</td>
<td>&nbsp;</td>
</tr>
<tr>
<td>Accept pipeline input?</td>
<td>false</td>
</tr>
<tr>
<td>Accept wildcard characters?</td>
<td>False</td>
</tr>
</tbody>
</table>
<p><strong>&lt;CommonParameters&gt;</strong></p>
<p style="margin-left:40px">This cmdlet supports the common parameters: Verbose, Debug,<br>
ErrorAction, ErrorVariable, WarningAction, WarningVariable,<br>
OutBuffer, PipelineVariable, and OutVariable.</p>
<p style="margin-left:40px">For more information, see <a href="http://go.microsoft.com/fwlink/?LinkID=113216">
a&#7;bout_CommonParameters</a>.</p>
<p><strong>INPUTS</strong></p>
<p><strong>OUTPUTS</strong></p>
<p style="margin-left:40px"><strong>Ionic.Zip.ZipEntry</strong></p>
<p><strong>NOTES</strong></p>
<p style="margin-left:40px">Par d&eacute;faut l'ajout d'une entr&eacute;e existante d&eacute;clenchera une exception.</p>
<p style="margin-left:40px">Cette fonction est coupl&eacute;e &agrave; la fonction nomm&eacute;e Expand-ZipEntry.</p>
<p><strong>EXAMPLES</strong></p>
<p style="margin-left:40px">-------------- EXAMPLE 1 --------------</p>
<pre style="margin-left:40px">PS C:\&gt; try {         
$ZipFile=Get-Zipfile -Path C:\Temp\Test.zip
$File=Get-Item C:\Temp\Test.ps1 
Add-ZipEntry -InputObject $File -ZipFile $ZipFile
} finally {
$ZipFile.Close()
}</pre>
<p style="margin-left:40px">Ces commandes ajoutent une entr&eacute;e dans l'archive C:\Temp\Test.zip:</p>
<p style="margin-left:40px; padding-left:30px">-La premi&egrave;re instruction cr&eacute;e un objet archive &agrave; partir d'un nom de fichier,</p>
<p style="margin-left:40px; padding-left:30px">-la seconde cr&eacute;e un objet fichier &agrave; partir d'un nom de fichier,</p>
<p style="margin-left:40px; padding-left:30px">-la troisi&egrave;me ajoute le fichier dans l'archive,</p>
<p style="margin-left:40px; padding-left:30px">-la quatri&egrave;me enregistre l'archive sur le disque et lib&egrave;re les ressources syst&egrave;mes.</p>
<p style="margin-left:40px">-------------- EXAMPLE 2 --------------</p>
<pre style="margin-left:40px">PS C:\&gt; try {         
$ZipFile=Get-Zipfile -Path C:\Temp\Test.zip
Get-ChildItem *.txt|Add-ZipEntry -ZipFile $ZipFile
} finally {
$ZipFile.Close()
}</pre>
<p style="margin-left:40px">Ces commandes ajoutent des entr&eacute;es dans l'archive C:\Temp\Test.zip :</p>
<p style="margin-left:40px; padding-left:30px">-La premi&egrave;re instruction cr&eacute;e un objet archive &agrave; partir d'un nom de fichier,</p>
<p style="margin-left:40px; padding-left:30px">-la seconde, depuis le r&eacute;pertoire courant, ajoute dans l'archive tous les fichiers portant l'extension .txt,</p>
<p style="margin-left:40px; padding-left:30px">-la troisi&egrave;me enregistre l'archive sur le disque et lib&egrave;re les ressources syst&egrave;mes.</p>
<p style="margin-left:40px">-------------- EXAMPLE 3 --------------</p>
<pre style="margin-left:40px">PS C:\&gt; try {         
$ZipFile=Get-Zipfile -Path C:\Temp\Test.zip
[string]$Text=Get-Content C:\Temp\Test.ps1|Out-String
Add-ZipEntry -InputObject $Text -Name MyText -ZipFile $ZipFile
} finally {
$ZipFile.Close()
}</pre>
<p style="margin-left:40px">Ces commandes ajoutent, &agrave; partir d'une cha&icirc;ne de caract&egrave;res, une entr&eacute;e nomm&eacute;e dans l'archive C:\Temp\Test.zip&nbsp; :</p>
<p style="margin-left:40px; padding-left:30px">-La premi&egrave;re instruction cr&eacute;e un objet archive &agrave; partir d'un nom de fichier,</p>
<p style="margin-left:40px; padding-left:30px">-la seconde lit un fichier texte et r&eacute;cup&egrave;re le r&eacute;sultat dans une cha&icirc;ne de caract&egrave;res,</p>
<p style="margin-left:40px; padding-left:30px">-la troisi&egrave;me cr&eacute;e une entr&eacute;e dont le contenu est renseign&eacute; &agrave; partir d'une cha&icirc;ne de caract&egrave;res,</p>
<p style="margin-left:40px; padding-left:30px">-la quatri&egrave;me enregistre l'archive sur le disque et lib&egrave;re les ressources syst&egrave;mes.</p>
<p style="margin-left:40px">-------------- EXAMPLE 4 --------------</p>
<pre style="margin-left:40px">PS C:\&gt; try {
$ZipFile=Get-Zipfile -Path C:\Temp\Test.zip         
ConvertTo-Clixml $PSVersionTable | Add-ZipEntry -Name 'PSVersiontable_clixml' -ZipFile $ZipFile
} finally {
$ZipFile.Close()
}</pre>
<p style="margin-left:40px">Ces commandes ajoutent, &agrave; partir d'un objet s&eacute;rialis&eacute;, une entr&eacute;e nomm&eacute;e dans l'archive C:\Temp\Test.zip :</p>
<p style="margin-left:40px; padding-left:30px">-La premi&egrave;re instruction cr&eacute;e un objet archive &agrave; partir d'un nom de fichier,</p>
<p style="margin-left:40px; padding-left:30px">-la seconde s&eacute;rialise l'objet contenu dans la variable
<em>$PSVersiontable</em> et l'ajoute en tant qu'entr&eacute;e nomm&eacute;e dans l'archive,</p>
<p style="margin-left:40px; padding-left:30px">-la troisi&egrave;me enregistre l'archive sur le disque et lib&egrave;re les ressources syst&egrave;mes.</p>
<p style="margin-left:40px">-------------- EXAMPLE 5 --------------</p>
<pre style="margin-left:40px">PS C:\&gt; try {         
$ZipFile=Get-Zipfile -Path C:\Temp\Test.zip 
[byte[]] $Array=@(1..20)
Add-ZipEntry -InputObject $Array -Name MyArray -ZipFile $ZipFile
} finally {
$ZipFile.Close()
}</pre>
<p style="margin-left:40px">Ces commandes ajoutent une entr&eacute;e nomm&eacute;e MyArray dans l'archive C:\Temp\Test.zip:</p>
<p style="margin-left:40px; padding-left:30px">-La premi&egrave;re instruction cr&eacute;e un objet archive &agrave; partir d'un nom de fichier,</p>
<p style="margin-left:40px; padding-left:30px">-la seconde ajoute l'objet contenu dans la variable
<em>$Array</em> et l'ajoute dans l'archive en tant qu'entr&eacute;e nomm&eacute;e MyArray,</p>
<p style="margin-left:40px; padding-left:30px">-la troisi&egrave;me enregistre l'archive sur le disque et lib&egrave;re les ressources syst&egrave;mes.</p>
<p><strong>RELATED LINKS</strong></p>
</div><div class="ClearBoth"></div>